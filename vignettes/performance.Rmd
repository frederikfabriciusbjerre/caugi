---
title: "Performance"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Performance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(1)
```

## Performance

This vignette discusses the performance characteristics of `caugi` including a comparison to the popular [`igraph` R package](https://igraph.org/r/) ([rigraph](https://github.com/igraph/rigraph)).
We focus on the practical trade-offs that arise from different core data structures and design choices.

The headline is: caugi frontloads computation.
That is, `caugi` spends more effort when constructing a graph and preparing indexes, so that queries are wicked fast. The high performance is also due to the Rust backend.

### Design choices

#### Compressed Sparse Row (CSR) representation

The core data structure in `caugi` is a Compressed Sparse Row (CSR) representation of the graph.
CSR stores for each vertex a contiguous slice of neighbor IDs with a pointer (offset) array that marks the start/end of each slice.
This format is memory efficient for sparse graphs. The `caugi` graph object also stores important query information in the object, leading to parent, child, and neighbor queries being done in $\mathcal{O}(1)$. This yields a larger memory footprint, but the trade-off is that queries are extremely fast.

#### Mutation and lazy building

The `caugi` graph objects are expensive to build. This is the performance downside of using `caugi`. For each time, we make a modification to a `caugi` graph object, we need to rebuild the graph completely, since the graph object is immutable by design. This has complexity $\mathcal{O}(|V| + |E|)$, where $V$ is the vertex set and $E$ is the edge set. 

However, the graph object will only be rebuild, when the user either calls `build()` directly or queries the graph. Therefore, you do not need to worry about wasting compute time by iteratively making changes to a `caugi` graph object, as the graph rebuilds lazily when queried. By doing this `caugi` graphs _feel_ mutable, but, in reality, they are not. 

By doing it this way, we ensure 
- that the graph object is always in a consistent state when queried, and
- that queries are as fast as possible,
while keeping the user experience smooth.

### Comparison

```{r setup}
library(caugi)
library(igraph)
library(microbenchmark)
```

We compare `caugi` to `igraph` on querying. 
We generate a random tree graph with 1000 nodes for the comparison.

```{r generate-graph}
ig <- igraph::make_tree(n = 1000)
cg <- caugi::as_caugi(ig, class = "DAG")
```
`
```{r benchmark-igraph-query}
microbenchmark(
  # igraph
  igraph_neighbors = igraph::neighbors(ig, 50),
  igraph_parents = igraph::neighbors(ig, 50, mode = "in"),
  igraph_children = igraph::neighbors(ig, 50, mode = "out"),

  # using index (fastest R side option)
  caugi_neighbors_index = caugi::neighbors(cg, index = 50),
  caugi_parents_index = caugi::parents(cg, index = 50),
  caugi_children_index = caugi::children(cg, index = 50),

  # using node name (same as index here)
  caugi_neighbors_parsed = caugi::neighbors(cg, nodes = 50),
  caugi_parents_parsed = caugi::parents(cg, nodes = "50"),
  caugi_children_parsed = caugi::children(cg, nodes = "50"),

  # using Rust backend directly (fastest possible, 0 indexed, less safe)
  caugi_neighbors_rust = caugi:::neighbors_of_ptr(cg@ptr, 49L),
  caugi_parents_rust = caugi:::parents_of_ptr(cg@ptr, 49L),
  caugi_children_rust = caugi:::children_of_ptr(cg@ptr, 49L),
  times = 10000
)
```

```{r library-gRbase}
library(gRbase)
```

```{r define_graphs}
# using gRbase to check d-separation
d_separates <- function(dag_, a, b, c) {
  ag <- ancestralGraph(c(a, b, c), dag_)
  separates(a, b, c, moralize(ag))
}

cg0 <- caugi_graph(
  A %-->% B + C + E,
  B %-->% C,
  C %-->% D,
  E %-->% D,
  F %-->% G,
  G %-->% E,
  class = "DAG",
  simple = TRUE,
  build = TRUE
)
grbg <- gRbase::dag(~a, ~ b * a, ~ c * a * b, ~ d * c * e, ~ e * a * g, ~ g * f)
ig <- caugi::as_igraph(cg0)
bng <- bnlearn::as.bn(ig)
ggmg <- ggm::DAG(
  A ~ B + C + E,
  B ~ C,
  C ~ D,
  E ~ D,
  F ~ G,
  G ~ E
) |> t()
```

```{r benchmark-parents-children}
microbenchmark(
  grbase = {
    gRbase::parents("d", grbg)
    gRbase::children("a", grbg)
  },
  caugi = {
    caugi::parents(cg0, D)
    caugi::children(cg0, A)
  },
  caugi_index = {
    caugi::parents(cg0, index = 7)
    caugi::children(cg0, index = 1)
  },
  caugi_rust = {
    caugi:::parents_of_ptr(cg0@ptr, 6L)
    caugi:::children_of_ptr(cg0@ptr, 0L)
  },
  igraph = {
    igraph::neighbors(ig, "D", mode = "in")
    igraph::neighbors(ig, "A", mode = "out")
  },
  bnlearn = {
    bnlearn::parents(bng, "D")
    bnlearn::children(bng, "A")
  },
  ggm = {
    ggm::pa("D", ggmg)
    ggm::ch("A", ggmg)
  },
  times = 1000
)
```

```{r benchmark-d-sep}
microbenchmark(
  grbase = d_separates(grbg, "c", "e", "a"),
  caugi = caugi::d_separated(cg0, C, E, A),
  caugi_rust = caugi:::is_d_separated_ptr(cg0@ptr, 2L, 3L, 0L),
  bnlearn = bnlearn::dsep(bng, "C", "E", "A"),
  ggm = ggm::dSep(ggmg, "C", "E", "A"),
  times = 1000
)
```

### Session info

```{r session-info}
sessionInfo()
```
