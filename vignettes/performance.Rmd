---
title: "Performance"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Performance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Performance

This vignette discusses the performance characteristics of `caugi` including a comparison to the popular [`igraph` R package](https://igraph.org/r/) ([rigraph](https://github.com/igraph/rigraph)).
We focus on the practical trade-offs that arise from different core data structures and design choices.

The headline is: caugi frontloads computation.
That is, `caugi` spends more effort when constructing a graph and preparing indexes, so that queries are wicked fast. The high performance is also due to the Rust backend.

### Design choices

#### Compressed Sparse Row (CSR) representation

The core data structure in `caugi` is a Compressed Sparse Row (CSR) representation of the graph.
CSR stores for each vertex a contiguous slice of neighbor IDs with a pointer (offset) array that marks the start/end of each slice.
This format is memory efficient for sparse graphs. The `caugi` graph object also stores important query information in the object, leading to parent, child, and neighbor queries being done in $\mathcal{O}(1)$. This yields a larger memory footprint, but the trade-off is that queries are extremely fast.

#### Mutation and lazy building

The `caugi` graph objects are expensive to build. This is the performance downside of using `caugi`. For each time, we make a modification to a `caugi` graph object, we need to rebuild the graph completely, since the graph object is immutable by design. This has complexity $\mathcal{O}(|V| + |E|)$, where $V$ is the vertex set and $E$ is the edge set. 

However, the graph object will only be rebuild, when the user either calls `build()` directly or queries the graph. Therefore, you do not need to worry about wasting compute time by iteratively making changes to a `caugi` graph object, as the graph rebuilds lazily when queried. By doing this `caugi` graphs _feel_ mutable, but, in reality, they are not. 

By doing it this way, we ensure 
- that the graph object is always in a consistent state when queried, and
- that queries are as fast as possible,
while keeping the user experience smooth.

### Comparison
```{r dagitty-conversion-fn-def, collapse=TRUE}
as_dagitty_bn <- function(x, ...) {
  nodes <- names(x$nodes)
  ee <- c()
  if (nrow(x$arcs) > 0) {
    ee <- apply(x$arcs, 1, function(a) {
      paste(a[1], "->", a[2])
    })
  }
  dagitty::dagitty(paste(
    "pdag{ ",
    paste(nodes, collapse = "\n"),
    paste(ee, collapse = "\n"),
    " }"
  ))
}
```

```{r setup}
library(bench)
```

We compare `caugi` to `igraph` on querying. 
We generate a random tree graph with 1000 nodes for the comparison.

```{r generate-graph}
set.seed(1)
ig <- igraph::sample_gnm(100, 500) |> igraph::as_directed(mode = "acyclic")
cg <- caugi::as_caugi(ig, class = "DAG")
ig <- igraph::sample_gnm(100, 500) |> igraph::as_directed(mode = "acyclic")
igraph::V(ig)$name <- paste0("V", 1:length(igraph::V(ig)))
cg <- caugi::as_caugi(ig, class = "DAG")
forms <- lapply(igraph::V(ig)$name, function(v) {
  pa <- names(igraph::neighbors(ig, v, mode = "in"))
  if (length(pa) == 0) {
    as.formula(paste0(v, " ~ 1"))
  } else {
    as.formula(paste(v, "~", paste(pa, collapse = "+")))
  }
})
ggmg <- do.call(ggm::DAG, forms)
bng <- bnlearn::as.bn(ig)
dg <- as_dagitty_bn(bng)
```

```{r benchmark-parents-children}
bench::mark(
  caugi_named = {
    caugi::parents(cg, "V50")
    caugi::children(cg, "V50")
  },
  caugi_index = {
    caugi::parents(cg, index = 50)
    caugi::children(cg, index = 50)
  },
  caugi_rust = {
    caugi:::parents_of_ptr(cg@ptr, 49L)
    caugi:::children_of_ptr(cg@ptr, 49L)
  },
  igraph = {
    igraph::neighbors(ig, "V50", mode = "in")
    igraph::neighbors(ig, "V50", mode = "out")
  },
  bnlearn = {
    bnlearn::parents(bng, "V50")
    bnlearn::children(bng, "V50")
  },
  ggm = {
    ggm::pa("V50", ggmg)
    ggm::ch("V50", ggmg)
  },
  dagitty = {
    dagitty::parents(dg, "V50")
    dagitty::children(dg, "V50")
  },
  check = FALSE # rust output are indexes, so check fails
) |> dplyr::arrange(median)
```

```{r benchmark-d-sep}
bench::mark(
  caugi = caugi::d_separated(cg, "V50", "V18", c("V8", "V20", "V43")),
  caugi_index = caugi::d_separated(cg,
    X_index = 50L, Y_index = 18L,
    Z_index = c(8L, 20L, 43L)
  ),
  caugi_rust = caugi:::d_separated_ptr(cg@ptr, 49L, 17L, c(7L, 19L, 42L)),
  bnlearn = bnlearn::dsep(bng, "V50", "V18", c("V8", "V20", "V43")),
  ggm = ggm::dSep(ggmg, "V50", "V18", c("V8", "V20", "V43")),
  dagitty = dagitty::dseparated(dg, "V50", "V18", c("V8", "V20", "V43")),
  check = FALSE # ggm returns FALSE, so check fails
) |> dplyr::arrange(median)
```

### Session info

```{r session-info}
sessionInfo()
```
