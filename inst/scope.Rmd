---
title: "Caugi"
author: "Frederik Fabricius-Bjerre"
date: "2025-09-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Causal Graph Interface (for R) — caugi

`caugi` is an R package for mixed causal graphs with a Rust core. It focuses on fast, deterministic queries over immutable graph snapshots, with edits staged lazily and materialized on demand. The API is tidy and integrates well with the **tidyverse**.

We aim to provide a purpose-built alternative to general graph tools (e.g., `igraph`) and domain tools (`dagitty`, `graph`, `ggm`, `bnlearn`, `pcalg`) while keeping conversions in and out easy.

The backend is written in Rust using a compact CSR-like layout and a typed edge system.

### Target users

Practitioners and researchers who work with causal graphs and need precise, efficient graph manipulation and querying.

---

## Core features — vision

### Creation

```{r, echo = TRUE, eval = FALSE}
caugi_graph(A %-->% B,
            B %<->% C,
            C %o->% D,
            D %o-o% E,
            E %o--% A,
            D %---% A)

# optional shorthand
cg(A %-->% B,
   B %<->% C,
   C %o->% D,
   D %o-o% E,
   E %o--% A,
   D %---% A)
```

### Conversion

From common graph objects and encodings:

```{r, echo = TRUE, eval = FALSE}
# igraph
as_caugi(igraph::make_graph(c(1,2, 2,3, 3,4, 5,6), directed = FALSE))
# or
as_cg(igraph::make_graph(c(1,2, 2,3, 3,4, 5,6), directed = FALSE))

# graphNEL
a s_caugi(graph::graphNEL(...))
# or
as_cg(graph::graphNEL(...))

# also planned
# - from adjacency matrix (dense or sparse)
# - from pcalg amat (cpdag or pag)
# - from data frame (from, to, edge_type)
# - from tidygraph
# - from dagitty
# - from bnlearn
# - from ggm

# and conversions back, when representable
as_igraph(cg)     # error if not fully directed/undirected when required
as_graphNEL(cg)
```

### Querying

#### `is_` functions

```{r, echo = TRUE, eval = FALSE}
is_dag(cg)
is_cpdag(cg)
is_pag(cg)
is_mixed(cg)
is_undirected(cg)
is_bidirected(cg)
is_bipartite(cg)
is_connected(cg)
is_tree(cg)
is_complete(cg)
is_eulerian(cg)      # may not be implemented
is_isomorphic(cg1, cg2)
is_planar(cg)        # may not be implemented
is_cyclic(cg)        # synonym: has_cycles(cg)
is_acyclic(cg)
is_collider(cg, node = B, path_from_to = c(A, C))
```

#### Basic queries

```{r, echo = TRUE, eval = FALSE}
nodes(cg)
edges(cg)
parents(cg, B)           # pa(cg, B)
children(cg, B)          # ch(cg, B)
neighbors(cg, B)         # nb(cg, B)
ancestors(cg, B)         # an(cg, B)
descendants(cg, B)       # de(cg, B)
markov_blanket(cg, B)    # mb(cg, B)
subgraph(cg, c("A","B","C"))
exogenous(cg)            # exo(cg)

adj_sets(cg, ...)        # minimal, Henckel variants, etc.
d_separated(cg, A, B, sepset = C)  # d_sep
m_separated(cg, ...)                 # m_sep
aid(cg1, cg2)                        # Optimal Adjustment Intervention Distance
instrumental_variables(cg, exposure, outcome)
topological_order(cg)

length(cg)               # number of nodes
```

### Mutation (lazy)

Edits record to an op-log; rebuild happens on the next query or via `build()`.

```{r, echo = TRUE, eval = FALSE}
add_edge(cg, A %-->% C)
remove_edge(cg, E %---% A)
set_edge_type(cg, C %o->% D)
rename_node(cg, A, X)
add_node(cg, Z)
remove_node(cg, E)
filter(cg, name %in% c("A","B","C"))  # subgraph(...)

# structural transforms
to_directed(cg)         # only for CPDAG/DAG/undirected where valid
to_undirected(cg)       # to_skeleton(cg)
to_cpdag(cg)            # only for DAGs
to_ancestral(x, cg)     # x = one or more nodes
to_mag(cg)

to_adj(cg, edge_type_encoding = FALSE)
canonicalize(cg)        # see dagitty
marginalize(cg)
fix(cg)                 # name TBD
do(cg)                  # maybe not
meeks(cg)               # PDAG → CPDAG

# build control
build(cg)               # force materialization of pending edits
```

### Node attributes

Latent/hidden, exposures, outcomes, with tidy verbs.

```{r, echo = TRUE, eval = FALSE}
# inline
cg <- caugi_graph(A %-->% B,
                  B %-->% C,
                  L %-->% C,
                  latent = c(L))

# post-hoc
a <- caugi_graph(A %-->% B, B %-->% C, L %-->% C)
latents(a) <- L                 # dagitty style

# tidy verbs
cg <- add_latents(cg, L)
cg <- add_latents(cg, L2) |> add_edge(L2 %-->% A)
# similar for exposures(cg) <- ..., outcomes(cg) <- ...
```

### Comparison

```{r, echo = TRUE, eval = FALSE}
shd(cg1, cg2)
hd(cg1, cg2)
sid(cg1, cg2)
aid(cg1, cg2)   # Oset-AID
```

### Simulation (stretch goals)

```{r, echo = TRUE, eval = FALSE}
# simulate specific graph types
simulate_dag(n = 5, p = 0.3)
simulate_cpdag(n = 5, p = 0.3)
simulate_pag(n = 5, p = 0.3)
# etc.

simulate_dag_from_cpdag(dag, n = 5)  # error or warning if n > class size

# simulate graphs with background knowledge
cg <- caugi_graph(A %-->% B) |>
  add_nodes(c("C","D","E"))
simulate_dag(nodes = nodes(cg), knowledge = cg)

# simulate data from a causal graph
simulate_data(cg, n = 1000, type = "linear", noise = "gaussian",
              connection_strength = c(0.1, 0.9))

simulate_data(cg, n = 1000, type = "polynomial", degree = 2, noise = "gaussian",
              connection_strength = c(0.1, 0.9))
```

### Non-goals

Causal discovery and effect estimation are out of scope. Focus is graph representation and manipulation.

### Design principles

* Simple, tidy API
* Fast, immutable query surface; lazy edits
* Deterministic results
* Comprehensive docs and examples
* Smooth interop and conversions

---

## Graph implementation details

### Data model and storage

* **Graph type:** `CaugiGraph` (general mixed causal graph).
* **IDs:** user-facing names (strings); internal dense `u32` node IDs. `usize` only for indexing in Rust.
* **Layout:** CSR-like with per-node **segmented neighborhoods** `[parents | undirected | children]` sorted ascending. Per-node counts `(in_deg, undirected_deg, out_deg)` stored in a side array for O(1) slicing.
* **Arrays:**

  * `row_ptr: Arc<[u32]>` length `|V|+1`
  * `nbr: Arc<[u32]>` length `Σ deg(v)`
  * `deg_splits: Arc<[(u32,u32,u32)]>` or equivalently two counts if undirected can be derived
  <!-- * `etype: Arc<[u8]>` -->
* **Constraints:** simple graphs, no self-loops, unless specifically allowed by the user. The user might want to represent graph types, we might not think are valid or favorable, as it will be used for research. Conflicting encodings rejected.

### Edge types and registry

* **Infix DSL:** Users may write `A %--<% B`, `C %o-O% D`, etc. **only after** defining the glyph via `caugi_define_edge(glyph, …)`.
* **Built-ins:** Real infix functions remain: `%-->%`, `%---%`, `%<->%`, `%o-o%`, `%o--%`, `%o->%`.
* **Parsing:** `%glyph%` tokens are parsed inside `caugi_*` calls; no global operator is installed by default. Evaluation outside constructors is unsupported unless a user defines their own operator separately.
* **Registry:** Up to 256 edge codes (`u8`). Each code stores explicit semantics; the printed `glyph` is cosmetic.

  * Schema per code: `{ glyph, left_mark, right_mark, orientation, class, symmetric, query_flags }`

    * `left_mark|right_mark ∈ { line, circle, arrow, other }`
    * `orientation ∈ { left_head, right_head, both_heads, none }`
    * `class ∈ { directed, undirected, bidirected, partial }`
    * `query_flags` govern parents/children/undirected membership and d/m-sep traversal.
* **API:**
  `caugi_define_edge(glyph, left_mark, right_mark, orientation, class, symmetric = FALSE, query_flags = list(...))` → returns a small integer code used in storage.
* **Determinism:** Registry is per-session and per-graph. On `build()` it is **sealed**, embedded, and serialized with the graph. Re-defining an existing `glyph` with different semantics **errors**.

### Build and mutation model

* **Immutable public graph.**
* R holds an **op-log** of changes. The object toggles `built = FALSE` on edit.
* **Lazy rebuild:** first query or explicit `build(cg)` applies the op-log:

  1. Collect to `Vec` buffers; sort, dedup, validate.
  2. Segment neighbors per node; compute degree splits.
  3. Freeze to `Arc<[T]>` and swap into a new snapshot.
* Example lifecycle:

```{r, echo = TRUE, eval = FALSE}
cg <- caugi_graph(A %-->% B)   # built = TRUE
cg <- add_nodes(c("C","D","E"))  # built = FALSE
is_dag(cg)                      # triggers rebuild -> built = TRUE
```

### Error handling

* Rust functions return `Result<…>`; R maps errors to conditions with readable messages. No panics on user input.

### Serialization

* `caugi_serialize(cg)` → `raw()` with versioned header, node-name table, edge-registry table, CSR arrays, degree splits.
* `caugi_deserialize(raw)` reconstructs immutable arrays (`Arc`) and the registry.

### Determinism and threading

* Deterministic outputs: neighbors sorted; stable ID remapping during build; fixed RNG seeds in tests.
* Multithreading off by default; opt-in later for heavy algorithms. Results must be deterministically ordered.

### Performance notes

* Build with `Vec`, finalize to `Arc<[T]>` to trim capacity and enable cheap snapshots.
* Remap node IDs for locality when building.
* Avoid per-edge tags when segmentation suffices; use `etype` only when needed.

### Project layout (rextendr; single crate start)

```
caugi/
  DESCRIPTION  NAMESPACE  R/
    zzz.R                  # .onLoad(): call rust_register_builtins()
    operators.R            # built-in infix: %-->%, %---%, %<->%, %o-o%, %o--%, %o->%
    edge_registry.R        # caugi_define_edge(), helpers
    graph.R                # R-facing constructors, add_edge(), build(), etc.
    extendr-wrappers.R     # auto-generated (do not edit)
  src/
    Makevars  Makevars.win  entrypoint.c
    rust/
      Cargo.toml            # [lib] crate-type = ["staticlib"]; extendr-api = ">=0.6"
      src/
        lib.rs              # extendr_module!; re-exports
        ffi.rs              # #[extendr] wrappers: new_registry, register_edge, new_graph, add_edge, build, ...
        edges/
          mod.rs            # EdgeSpec, EdgeRegistry, flags
          bitflags.rs
        graph/
          mod.rs            # CaugiGraph
          csr.rs            # row_ptr, nbr, deg_splits (Arc<[u32]>, Arc<[(u32,u32,u32)]>)
          builder.rs        # op-log apply → finalize
          edgelist.rs       # streaming loaders
        queries/
          is_dag.rs  is_pdag.rs  is_cpdag.rs
        util/
          idmap.rs  errors.rs
      tests/                # Rust unit/property tests
  tests/testthat/           # R tests

```

### Tooling, CI, and licensing

* Rust: edition 2021, MSRV \~ 1.72 (no nightly).
* R: built via **rextendr**.
* CI: `R CMD check` + `cargo test` on macOS/Windows/Linux.
* License: **MIT** for R and Rust.

